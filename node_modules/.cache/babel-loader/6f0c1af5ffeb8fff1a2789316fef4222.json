{"ast":null,"code":"var _jsxFileName = \"/Users/davidnewberry/Documents/rifftube-git/RiffTube/front-end/src/components/ViewInterface/ViewFilter.js\";\nimport React from 'react';\nimport YouTubeVideo from '../YouTubeVideo/YouTubeVideo';\n\nclass ViewFilter extends React.Component {\n  constructor(props) {\n    super(props); // window.metaPlayhead gets updated by the youtube component\n\n    this.selectRiff = newRiff => {\n      // use id to find riff in \"master\" list\n      //const riff = this.props.riffs.find( r => r.id == selected_id );\n      let riff;\n      if (this.state.nonOverlappingRiffs.has(riff)) return;\n      const selectedRiffs = new Set(this.state.selectedRiffs);\n      const newFiltered = new Set(this.props.riffs);\n      const otherOverlaps = new Set(); //new Set( this.state.overlappingRiffs );\n\n      this.state.overlappingRiffs.forEach(el => otherOverlaps.add(new Set(el)));\n      riff = newRiff;\n\n      do {\n        // go through each set of overlapping riffs\n        for (const set of this.state.overlappingRiffs) {\n          // if that set contains the selected riff, remove all its values from the\n          if (set.has(riff)) {\n            set.forEach(el => {\n              selectedRiffs.delete(el);\n              newFiltered.delete(el);\n            });\n          }\n        }\n\n        selectedRiffs.add(riff); // now the hard part\n\n        for (const r of selectedRiffs) {\n          // find and delete sets of overlap that contain a selected riff\n          const toDelete = [];\n\n          for (const set of otherOverlaps) {\n            if (set.has(r)) {\n              toDelete.push(set);\n            }\n          }\n\n          for (const set of toDelete) {\n            otherOverlaps.delete(set); // from the sets in question, remove all their riffs from other overlap sets\n            // (because they are no longer valid options)\n\n            var curOverlap = new Set();\n\n            for (const redu of otherOverlaps) {\n              for (const tod of set) {\n                newFiltered.delete(tod);\n                redu.delete(tod);\n              }\n            }\n          }\n        }\n\n        for (const redu of otherOverlaps) {\n          if (redu.size > 0) curOverlap = new Set([...curOverlap, ...redu]);\n        }\n\n        if (curOverlap.size > 0) riff = curOverlap.values().next().value;\n      } while (curOverlap.size > 0); // generate final filtered list\n\n\n      const filteredRiffs = [...newFiltered, ...selectedRiffs];\n      this.setState({\n        filteredRiffs,\n        selectedRiffs\n      });\n    };\n\n    window.metaPlayHead = React.createRef();\n    this.selectDiv = React.createRef();\n\n    window.metaUpdate = el => {\n      if (this.selectDiv.current) // seems like it shouldn't be needed, but here we are\n        this.selectDiv.current.scrollLeft = el.offsetLeft - this.selectDiv.current.offsetWidth / 2;\n    };\n\n    this.state = {\n      filteredRiffs: [],\n      overlappingRiffs: [],\n      nonOverlappingRiffs: null,\n      selectedRiffs: null,\n      tracks: []\n    }; // filtered riffs is the final result\n    // overlapping riffs is a list of sets [of ids] of overlapping riffs\n    // selected riffs is a set\n    // tracks are used for the UI\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.riffs !== this.props.riffs) {\n      debugger; // if riffs have changed, we need to recalculate\n      // multiple tracks are used to display overlapping riffs at the same time\n\n      const tracks = [[]];\n      const trackPos = [0]; // time code where last riff on track ends\n\n      const nonOverlappingRiffs = new Set(); // used to keep track of conflicting riffs\n\n      const runningRiffs = []; // these will overwrite the current values after being built\n\n      const overlappingRiffs = [];\n      const selectedRiffs = new Set(); // slope basically means \"was the last action to add or remove from the running list\"\n\n      var slope = 0; // sort riffs by starting time\n\n      this.props.riffs.sort((e1, e2) => e1.time - e2.time); // loop through sorted riffs\n\n      for (const riff of this.props.riffs) {\n        // check to see if any riffs end before this riff starts\n        if (runningRiffs.length > 0) {\n          // this could be optimized by first sorting running set\n          const toDelete = [];\n\n          for (const toCheck of runningRiffs) {\n            // (see above)\n            if (toCheck.time + toCheck.duration <= riff.time) {\n              // only add set if the prev action was an add,\n              // and there is more than 1 riff in the set\n              if (slope > 0 && runningRiffs.length > 1) {\n                overlappingRiffs.push(new Set(runningRiffs)); // when adding overlapping set, find if any are in track 0\n                // if so, they go into selectedRiffs\n\n                for (const candi of runningRiffs) {\n                  if (tracks[0].includes(candi)) {\n                    selectedRiffs.add(candi);\n                    break;\n                  }\n                }\n              } else if (slope > 0) {\n                // 'if' part may be unnecessary\n                nonOverlappingRiffs.add(toCheck);\n              } // don't delete in place while looping\n\n\n              toDelete.push(toCheck);\n              slope = -1; // last action was to remove\n            }\n          }\n\n          for (const el of toDelete) runningRiffs.splice(runningRiffs.indexOf(el), 1);\n        } // add this riff to running list\n\n\n        runningRiffs.push(riff); // keep running list sorted by first ending\n\n        runningRiffs.sort((e1, e2) => e1.time + e1.duration - (e2.time + e2.duration)); // last action was to add\n\n        slope = 1; // assign riff to a track\n\n        var flag = true;\n\n        for (var i = 0; i < tracks.length; i++) {\n          // check whether this track is available\n          if (trackPos[i] <= riff.time) {\n            tracks[i].push(riff);\n            trackPos[i] = riff.time + riff.duration;\n            flag = false;\n            break;\n          }\n        } // if no track was found, add one\n\n\n        if (flag) {\n          tracks.push([riff]);\n          trackPos.push(riff.time + riff.duration);\n        }\n      } // cleanup after loop\n      // check to see if running set has more than 1 riff\n      // if so, add it etc.\n\n\n      if (runningRiffs.length > 1) {\n        overlappingRiffs.push(new Set(runningRiffs));\n\n        for (const candi of runningRiffs) {\n          if (tracks[0].includes(candi)) {\n            selectedRiffs.add(candi);\n            break;\n          }\n        }\n      } else nonOverlappingRiffs.add(runningRiffs[0]);\n\n      const filteredRiffs = [...tracks[0]];\n      this.setState({\n        filteredRiffs,\n        overlappingRiffs,\n        nonOverlappingRiffs,\n        selectedRiffs,\n        tracks\n      });\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 214,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(YouTubeVideo, {\n      id: this.props.id,\n      riffs: this.state.filteredRiffs,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 215,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      ref: this.selectDiv,\n      style: {\n        fontSize: '2em',\n        overflow: 'hidden',\n        width: '640px'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 216,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        height: `${this.state.tracks.length * 0.75}em`,\n        width: `${this.props.duration}em`,\n        position: 'relative'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 220,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      id: \"meta-play-head\",\n      style: {\n        backgroundColor: 'red',\n        height: 'inherit'\n      },\n      ref: window.metaPlayHead,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 227,\n        columnNumber: 13\n      }\n    }), this.state.tracks.map(trackArray => /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        width: `${this.props.duration}em`,\n        height: '0.75em'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 233,\n        columnNumber: 15\n      }\n    }, trackArray.map(riff => /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        position: 'absolute',\n        overflow: 'hidden',\n        textOverflow: 'ellipsis',\n        whiteSpace: 'nowrap',\n        fontSize: '0.25em',\n        lineHeight: '3em',\n        verticalAlign: 'middle',\n        left: `${riff.time * 4}em`,\n        height: '3em',\n        width: `${riff.duration * 4}em`,\n        backgroundColor: this.state.filteredRiffs.includes(riff) ? 'red' : 'lightgrey'\n      },\n      onClick: () => this.selectRiff(riff),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 237,\n        columnNumber: 19\n      }\n    }, riff.name)))))));\n  }\n\n}\n\nexport default ViewFilter;","map":{"version":3,"names":["React","YouTubeVideo","ViewFilter","Component","constructor","props","selectRiff","newRiff","riff","state","nonOverlappingRiffs","has","selectedRiffs","Set","newFiltered","riffs","otherOverlaps","overlappingRiffs","forEach","el","add","set","delete","r","toDelete","push","curOverlap","redu","tod","size","values","next","value","filteredRiffs","setState","window","metaPlayHead","createRef","selectDiv","metaUpdate","current","scrollLeft","offsetLeft","offsetWidth","tracks","componentDidUpdate","prevProps","trackPos","runningRiffs","slope","sort","e1","e2","time","length","toCheck","duration","candi","includes","splice","indexOf","flag","i","render","id","fontSize","overflow","width","height","position","backgroundColor","map","trackArray","textOverflow","whiteSpace","lineHeight","verticalAlign","left","name"],"sources":["/Users/davidnewberry/Documents/rifftube-git/RiffTube/front-end/src/components/ViewInterface/ViewFilter.js"],"sourcesContent":["import React from 'react';\nimport YouTubeVideo from '../YouTubeVideo/YouTubeVideo';\n\nclass ViewFilter extends React.Component {\n  constructor(props) {\n    super(props);\n    // window.metaPlayhead gets updated by the youtube component\n    window.metaPlayHead = React.createRef();\n    this.selectDiv = React.createRef();\n    window.metaUpdate = (el) => {\n      if (this.selectDiv.current)\n        // seems like it shouldn't be needed, but here we are\n        this.selectDiv.current.scrollLeft =\n          el.offsetLeft - this.selectDiv.current.offsetWidth / 2;\n    };\n\n    this.state = {\n      filteredRiffs: [],\n      overlappingRiffs: [],\n      nonOverlappingRiffs: null,\n      selectedRiffs: null,\n      tracks: [],\n    };\n    // filtered riffs is the final result\n    // overlapping riffs is a list of sets [of ids] of overlapping riffs\n    // selected riffs is a set\n    // tracks are used for the UI\n  }\n\n  selectRiff = (newRiff) => {\n    // use id to find riff in \"master\" list\n    //const riff = this.props.riffs.find( r => r.id == selected_id );\n    let riff;\n    if (this.state.nonOverlappingRiffs.has(riff)) return;\n\n    const selectedRiffs = new Set(this.state.selectedRiffs);\n\n    const newFiltered = new Set(this.props.riffs);\n\n    const otherOverlaps = new Set(); //new Set( this.state.overlappingRiffs );\n    this.state.overlappingRiffs.forEach((el) => otherOverlaps.add(new Set(el)));\n\n    riff = newRiff;\n\n    do {\n      // go through each set of overlapping riffs\n      for (const set of this.state.overlappingRiffs) {\n        // if that set contains the selected riff, remove all its values from the\n        if (set.has(riff)) {\n          set.forEach((el) => {\n            selectedRiffs.delete(el);\n            newFiltered.delete(el);\n          });\n        }\n      }\n\n      selectedRiffs.add(riff);\n\n      // now the hard part\n\n      for (const r of selectedRiffs) {\n        // find and delete sets of overlap that contain a selected riff\n        const toDelete = [];\n        for (const set of otherOverlaps) {\n          if (set.has(r)) {\n            toDelete.push(set);\n          }\n        }\n        for (const set of toDelete) {\n          otherOverlaps.delete(set);\n          // from the sets in question, remove all their riffs from other overlap sets\n          // (because they are no longer valid options)\n          var curOverlap = new Set();\n          for (const redu of otherOverlaps) {\n            for (const tod of set) {\n              newFiltered.delete(tod);\n              redu.delete(tod);\n            }\n          }\n        }\n      }\n      for (const redu of otherOverlaps) {\n        if (redu.size > 0) curOverlap = new Set([...curOverlap, ...redu]);\n      }\n\n      if (curOverlap.size > 0) riff = curOverlap.values().next().value;\n    } while (curOverlap.size > 0);\n\n    // generate final filtered list\n    const filteredRiffs = [...newFiltered, ...selectedRiffs];\n\n    this.setState({ filteredRiffs, selectedRiffs });\n  };\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.riffs !== this.props.riffs) {\n      debugger;\n\n      // if riffs have changed, we need to recalculate\n\n      // multiple tracks are used to display overlapping riffs at the same time\n      const tracks = [[]];\n      const trackPos = [0]; // time code where last riff on track ends\n\n      const nonOverlappingRiffs = new Set();\n\n      // used to keep track of conflicting riffs\n      const runningRiffs = [];\n\n      // these will overwrite the current values after being built\n      const overlappingRiffs = [];\n      const selectedRiffs = new Set();\n\n      // slope basically means \"was the last action to add or remove from the running list\"\n      var slope = 0;\n\n      // sort riffs by starting time\n      this.props.riffs.sort((e1, e2) => e1.time - e2.time);\n\n      // loop through sorted riffs\n      for (const riff of this.props.riffs) {\n        // check to see if any riffs end before this riff starts\n        if (runningRiffs.length > 0) {\n          // this could be optimized by first sorting running set\n          const toDelete = [];\n          for (const toCheck of runningRiffs) {\n            // (see above)\n            if (toCheck.time + toCheck.duration <= riff.time) {\n              // only add set if the prev action was an add,\n              // and there is more than 1 riff in the set\n              if (slope > 0 && runningRiffs.length > 1) {\n                overlappingRiffs.push(new Set(runningRiffs));\n\n                // when adding overlapping set, find if any are in track 0\n                // if so, they go into selectedRiffs\n                for (const candi of runningRiffs) {\n                  if (tracks[0].includes(candi)) {\n                    selectedRiffs.add(candi);\n                    break;\n                  }\n                }\n              } else if (slope > 0) {\n                // 'if' part may be unnecessary\n                nonOverlappingRiffs.add(toCheck);\n              }\n\n              // don't delete in place while looping\n              toDelete.push(toCheck);\n              slope = -1; // last action was to remove\n            }\n          }\n          for (const el of toDelete)\n            runningRiffs.splice(runningRiffs.indexOf(el), 1);\n        }\n\n        // add this riff to running list\n        runningRiffs.push(riff);\n\n        // keep running list sorted by first ending\n        runningRiffs.sort(\n          (e1, e2) => e1.time + e1.duration - (e2.time + e2.duration)\n        );\n\n        // last action was to add\n        slope = 1;\n\n        // assign riff to a track\n        var flag = true;\n        for (var i = 0; i < tracks.length; i++) {\n          // check whether this track is available\n          if (trackPos[i] <= riff.time) {\n            tracks[i].push(riff);\n            trackPos[i] = riff.time + riff.duration;\n            flag = false;\n            break;\n          }\n        }\n\n        // if no track was found, add one\n        if (flag) {\n          tracks.push([riff]);\n          trackPos.push(riff.time + riff.duration);\n        }\n      }\n\n      // cleanup after loop\n      // check to see if running set has more than 1 riff\n      // if so, add it etc.\n      if (runningRiffs.length > 1) {\n        overlappingRiffs.push(new Set(runningRiffs));\n\n        for (const candi of runningRiffs) {\n          if (tracks[0].includes(candi)) {\n            selectedRiffs.add(candi);\n            break;\n          }\n        }\n      } else nonOverlappingRiffs.add(runningRiffs[0]);\n\n      const filteredRiffs = [...tracks[0]];\n\n      this.setState({\n        filteredRiffs,\n        overlappingRiffs,\n        nonOverlappingRiffs,\n        selectedRiffs,\n        tracks,\n      });\n    }\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        <YouTubeVideo id={this.props.id} riffs={this.state.filteredRiffs} />\n        <div\n          ref={this.selectDiv}\n          style={{ fontSize: '2em', overflow: 'hidden', width: '640px' }}\n        >\n          <div\n            style={{\n              height: `${this.state.tracks.length * 0.75}em`,\n              width: `${this.props.duration}em`,\n              position: 'relative',\n            }}\n          >\n            <div\n              id=\"meta-play-head\"\n              style={{ backgroundColor: 'red', height: 'inherit' }}\n              ref={window.metaPlayHead}\n            />\n            {this.state.tracks.map((trackArray) => (\n              <div\n                style={{ width: `${this.props.duration}em`, height: '0.75em' }}\n              >\n                {trackArray.map((riff) => (\n                  <div\n                    style={{\n                      position: 'absolute',\n                      overflow: 'hidden',\n                      textOverflow: 'ellipsis',\n                      whiteSpace: 'nowrap',\n                      fontSize: '0.25em',\n                      lineHeight: '3em',\n                      verticalAlign: 'middle',\n                      left: `${riff.time * 4}em`,\n                      height: '3em',\n                      width: `${riff.duration * 4}em`,\n                      backgroundColor: this.state.filteredRiffs.includes(riff)\n                        ? 'red'\n                        : 'lightgrey',\n                    }}\n                    onClick={() => this.selectRiff(riff)}\n                  >\n                    {riff.name}\n                  </div>\n                ))}\n              </div>\n            ))}\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default ViewFilter;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}