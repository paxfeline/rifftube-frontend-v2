{"ast":null,"code":"import { SET_VIDEO_ID, DELETE_RIFF, SAVE_RIFF, CREATE_TEMP_AUDIO_RIFF, CREATE_TEMP_TEXT_RIFF, SAVE_TEMP_AUDIO, CANCEL_EDIT, EDIT_RIFF, RECEIVE_RIFF_LIST, SAVE_RIFF_SUCCESS, UPDATE_RIFF_TIME_SUCCESS } from '../actions/index.js';\nlet initialState = {\n  all: [],\n  temp: null,\n  editIndex: null\n};\n\nconst riffsReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case SET_VIDEO_ID:\n      return initialState;\n\n    case CREATE_TEMP_AUDIO_RIFF:\n    case CREATE_TEMP_TEXT_RIFF:\n      return { ...state,\n        temp: { ...state.temp,\n          type: action.type === CREATE_TEMP_AUDIO_RIFF ? 'audio' : 'text',\n          // @ts-ignore\n          // rifftubePlayer isn't normally on the window object so this throws an error but it works.\n          time: window.rifftubePlayer.getCurrentTime(),\n          video_id: action.videoID,\n          tempId: new Date().getUTCMilliseconds() // used to get perm id from server\n\n        },\n        editIndex: null\n      };\n\n    case EDIT_RIFF:\n      return { ...state,\n        temp: { ...state.all[action.payload]\n        },\n        // copy specified riff to tempRiff\n        editIndex: action.payload\n      };\n\n    case DELETE_RIFF:\n      {\n        let ret = { ...state\n        };\n        ret.all = ret.all.filter(el => el.id !== action.id); // silly change\n\n        /*let index = ret.all.findIndex(el => el.id === action.id);\n           ret.all.splice(index, 1);*/\n\n        return ret;\n      }\n\n    case SAVE_TEMP_AUDIO:\n      return { ...state,\n        temp: { ...state.temp,\n          duration: action.duration //payload: action.payload\n\n        }\n      };\n\n    case CANCEL_EDIT:\n      return { ...state,\n        temp: null,\n        editIndex: null\n      };\n\n    case RECEIVE_RIFF_LIST:\n      return { ...state,\n        timestamp: action.payload.timestamp,\n        all: action.payload.body.map(el => ({ ...el,\n          time: el.start_time,\n          payload: el.isText ? el.text : null,\n          type: el.isText ? 'text' : 'audio'\n        }))\n      };\n\n    case UPDATE_RIFF_TIME_SUCCESS:\n      let riffs = [...state.all];\n      riffs.forEach((el, ind, arr) => {\n        if (el.id === action.id) arr[ind] = { ...el,\n          id: action.id,\n          time: Number(action.time)\n        }; //el.id = action.payload.id;\n      });\n      let ret = { ...state,\n        all: riffs\n      };\n      return ret;\n\n    case SAVE_RIFF_SUCCESS:\n      if (action.payload.type === 'add') {\n        let riffs = [...state.all];\n        riffs.forEach((el, ind, arr) => {\n          if (el.tempId === action.payload.tempId) arr[ind] = { ...el,\n            id: action.payload.id\n          }; //el.id = action.payload.id;\n        });\n        let ret = { ...state,\n          all: riffs\n        };\n        return ret;\n      } else return state;\n\n    case SAVE_RIFF:\n      {\n        const {\n          payload,\n          ...actionPayload\n        } = action.payload; // payload (audio data) will be ignored\n\n        const riff = { ...state.temp,\n          ...actionPayload\n        }; // the payload should be included if this is a text riff\n\n        if (state.temp.type === \"text\") riff.payload = payload;\n        let riffs; // adding a new riff:\n\n        if (state.editIndex === null) riffs = [...state.all, riff]; // EDIT_MODE (existing riff):\n        else {\n          riffs = [...state.all];\n          riffs[state.editIndex] = riff;\n        }\n        return {\n          all: riffs,\n          temp: null,\n          editIndex: null\n        };\n      }\n\n    /*\n    case LOAD_RIFF:\n      let ret = { ...state }; // will this work?\n      ret.all[action.payload].loading = true;\n      return ret;\n    case RIFF_LOADED: {\n      debugger;\n      const b = new Blob(new Array(action.payload), { type: 'audio/mp3' });\n      let riffs = [...state.all];\n      riffs.forEach(el => {\n        if (el.id === action.id) {\n          el.payload = b;\n          el.loading = false;\n        }\n      });\n      let ret = { ...state, all: riffs };\n       // if this is being edited currently, tempRiff needs to be updated as well\n      // editIndex != null simply means that something is being edited\n      if (state.editIndex !== null && state.temp.id === action.id)\n        ret.temp = { ...ret.temp, payload: b };\n       return ret;\n    }\n    */\n\n    default:\n      return state;\n  }\n};\n\nexport default riffsReducer;","map":{"version":3,"names":["SET_VIDEO_ID","DELETE_RIFF","SAVE_RIFF","CREATE_TEMP_AUDIO_RIFF","CREATE_TEMP_TEXT_RIFF","SAVE_TEMP_AUDIO","CANCEL_EDIT","EDIT_RIFF","RECEIVE_RIFF_LIST","SAVE_RIFF_SUCCESS","UPDATE_RIFF_TIME_SUCCESS","initialState","all","temp","editIndex","riffsReducer","state","action","type","time","window","rifftubePlayer","getCurrentTime","video_id","videoID","tempId","Date","getUTCMilliseconds","payload","ret","filter","el","id","duration","timestamp","body","map","start_time","isText","text","riffs","forEach","ind","arr","Number","actionPayload","riff"],"sources":["/Users/davidnewberry/Documents/rifftube-git/RiffTube/front-end/src/reducers/riffs-reducer.js"],"sourcesContent":["import {\n  SET_VIDEO_ID,\n  DELETE_RIFF,\n  SAVE_RIFF,\n  CREATE_TEMP_AUDIO_RIFF,\n  CREATE_TEMP_TEXT_RIFF,\n  SAVE_TEMP_AUDIO,\n  CANCEL_EDIT,\n  EDIT_RIFF,\n  RECEIVE_RIFF_LIST,\n  SAVE_RIFF_SUCCESS,\n  UPDATE_RIFF_TIME_SUCCESS,\n} from '../actions/index.js';\n\nlet initialState = {\n  all: [],\n  temp: null,\n  editIndex: null,\n};\n\nconst riffsReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case SET_VIDEO_ID:\n      return initialState;\n    case CREATE_TEMP_AUDIO_RIFF:\n    case CREATE_TEMP_TEXT_RIFF:\n      return {\n        ...state,\n        temp: {\n          ...state.temp,\n          type: action.type === CREATE_TEMP_AUDIO_RIFF ? 'audio' : 'text',\n          // @ts-ignore\n          // rifftubePlayer isn't normally on the window object so this throws an error but it works.\n          time: window.rifftubePlayer.getCurrentTime(),\n          video_id: action.videoID,\n          tempId: new Date().getUTCMilliseconds(), // used to get perm id from server\n        },\n        editIndex: null,\n      };\n    case EDIT_RIFF:\n      return {\n        ...state,\n        temp: { ...state.all[action.payload] }, // copy specified riff to tempRiff\n        editIndex: action.payload,\n      };\n    case DELETE_RIFF: {\n      let ret = { ...state };\n\n      ret.all = ret.all.filter((el) => el.id !== action.id);\n\n      // silly change\n\n      /*let index = ret.all.findIndex(el => el.id === action.id);\n\n\n\n      ret.all.splice(index, 1);*/\n\n      return ret;\n    }\n    case SAVE_TEMP_AUDIO:\n      return {\n        ...state,\n        temp: {\n          ...state.temp,\n          duration: action.duration,\n          //payload: action.payload\n        },\n      };\n    case CANCEL_EDIT:\n      return {\n        ...state,\n        temp: null,\n        editIndex: null,\n      };\n    case RECEIVE_RIFF_LIST:\n      return {\n        ...state,\n        timestamp: action.payload.timestamp,\n        all: action.payload.body.map((el) => ({\n          ...el,\n          time: el.start_time,\n          payload: el.isText ? el.text : null,\n          type: el.isText ? 'text' : 'audio',\n        })),\n      };\n\n    case UPDATE_RIFF_TIME_SUCCESS:\n      let riffs = [...state.all];\n      riffs.forEach((el, ind, arr) => {\n        if (el.id === action.id)\n          arr[ind] = { ...el, id: action.id, time: Number(action.time) };\n        //el.id = action.payload.id;\n      });\n      let ret = { ...state, all: riffs };\n      return ret;\n\n    case SAVE_RIFF_SUCCESS:\n      if (action.payload.type === 'add') {\n        let riffs = [...state.all];\n        riffs.forEach((el, ind, arr) => {\n          if (el.tempId === action.payload.tempId)\n            arr[ind] = { ...el, id: action.payload.id };\n          //el.id = action.payload.id;\n        });\n        let ret = { ...state, all: riffs };\n        return ret;\n      } else return state;\n\n    case SAVE_RIFF: {\n      const { payload, ...actionPayload } = action.payload; // payload (audio data) will be ignored\n      const riff = { ...state.temp, ...actionPayload };\n\n      // the payload should be included if this is a text riff\n      if ( state.temp.type === \"text\" )\n        riff.payload = payload;\n\n      let riffs;\n\n      // adding a new riff:\n      if (state.editIndex === null) riffs = [...state.all, riff];\n      // EDIT_MODE (existing riff):\n      else {\n        riffs = [...state.all];\n        riffs[state.editIndex] = riff;\n      }\n\n      return {\n        all: riffs,\n        temp: null,\n        editIndex: null,\n      };\n    }\n\n    /*\n    case LOAD_RIFF:\n      let ret = { ...state }; // will this work?\n      ret.all[action.payload].loading = true;\n      return ret;\n    case RIFF_LOADED: {\n      debugger;\n      const b = new Blob(new Array(action.payload), { type: 'audio/mp3' });\n      let riffs = [...state.all];\n      riffs.forEach(el => {\n        if (el.id === action.id) {\n          el.payload = b;\n          el.loading = false;\n        }\n      });\n      let ret = { ...state, all: riffs };\n\n      // if this is being edited currently, tempRiff needs to be updated as well\n      // editIndex != null simply means that something is being edited\n      if (state.editIndex !== null && state.temp.id === action.id)\n        ret.temp = { ...ret.temp, payload: b };\n\n      return ret;\n    }\n    */\n\n    default:\n      return state;\n  }\n};\n\nexport default riffsReducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}