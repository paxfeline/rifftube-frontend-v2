{"ast":null,"code":"var _jsxFileName = \"/Users/davidnewberry/Documents/rifftube-git/RiffTube/front-end/src/components/RiffControls/Record.js\";\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { setImmediateOff } from '../../actions/index.js';\n\nclass Record extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.endRecord = () => {\n      if (this.props.recorder == null) return; // do nothing if recording isn't yet allowed\n\n      this.setState({\n        recordingState: false\n      });\n      this.duration = (Date.now() - this.startTime) / 1000; // experimenting this.state.gumStream.getAudioTracks()[0].stop();\n\n      this.props.recorder.finishRecording(); // create new stream -- NEEDED???? experimenting\n\n      /*navigator.mediaDevices\n        .getUserMedia({ audio: true, video: false })\n        .then((stream) => {\n          this.setState({ gumStream: stream });\n        })\n        .catch(function (err) {\n          //enable the record button if getUSerMedia() fails\n          console.log(\"oops, can't get stream\", err);\n        });\n        */\n    };\n\n    this.startRecord = () => {\n      if (this.props.recorder == null) return; // do nothing if recording isn't yet allowed\n\n      this.setState({\n        recordingState: true\n      });\n      this.startTime = Date.now(); //this.state.mediaRecorder.start();\n\n      this.props.recorder.onComplete = (recorder, blob) => {\n        //createDownloadLink(blob, recorder.encoding);\n        this.props.saveTempAudio(blob, this.duration);\n      };\n\n      this.props.recorder.setOptions({\n        timeLimit: 120,\n        encodeAfterRecord: true,\n        mp3: {\n          bitRate: 160\n        }\n      }); //start the recording process\n\n      setTimeout(() => this.props.recorder.startRecording(), 200); // delay start to avoid clicks and taps\n    };\n\n    this.state = {\n      recordingState: false\n    };\n  } // arrow classes bind the methods properly\n\n\n  componentDidMount() {\n    console.log(\"record CDM\", this.props.userMedia);\n\n    if (this.props.immediateRecord) {\n      console.log(\"start immediately\");\n      this.startRecord();\n      setImmediateOff();\n      window.addEventListener('keyup', e => {\n        if (e.key == 'r') this.endRecord();\n      });\n    }\n  }\n\n  render() {\n    var ret; // var for the value to be returned\n\n    if (navigator.mediaDevices) {\n      if (!this.state.recordingState) {\n        ret = /*#__PURE__*/React.createElement(\"button\", {\n          id: \"recordBtn\",\n          onClick: this.startRecord,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 80,\n            columnNumber: 11\n          }\n        }, \"Record\");\n      } else {\n        ret = /*#__PURE__*/React.createElement(\"button\", {\n          id: \"stopBtn\",\n          onClick: this.endRecord,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 89,\n            columnNumber: 11\n          }\n        }, \"stop\");\n      }\n    } else ret = /*#__PURE__*/React.createElement(\"span\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 99,\n        columnNumber: 9\n      }\n    }, \"Your device is not supported by navigator.mediaDevices. Sorry.\");\n\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 104,\n        columnNumber: 12\n      }\n    }, ret);\n  }\n\n}\n\nconst mapStateToProps = state => ({\n  immediateRecord: state.immediateRecord,\n  recorder: state.recorder\n});\n\nconst mapDispatchToProps = {\n  setImmediateOff\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(Record);","map":{"version":3,"names":["React","connect","setImmediateOff","Record","Component","constructor","props","endRecord","recorder","setState","recordingState","duration","Date","now","startTime","finishRecording","startRecord","onComplete","blob","saveTempAudio","setOptions","timeLimit","encodeAfterRecord","mp3","bitRate","setTimeout","startRecording","state","componentDidMount","console","log","userMedia","immediateRecord","window","addEventListener","e","key","render","ret","navigator","mediaDevices","mapStateToProps","mapDispatchToProps"],"sources":["/Users/davidnewberry/Documents/rifftube-git/RiffTube/front-end/src/components/RiffControls/Record.js"],"sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport {\n  setImmediateOff,\n} from '../../actions/index.js';\n\nclass Record extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      recordingState: false,\n    };\n  }\n\n  // arrow classes bind the methods properly\n\n  endRecord = () => {\n    if (this.props.recorder == null) return; // do nothing if recording isn't yet allowed\n\n    this.setState({ recordingState: false });\n    this.duration = (Date.now() - this.startTime) / 1000;\n\n    // experimenting this.state.gumStream.getAudioTracks()[0].stop();\n    this.props.recorder.finishRecording();\n\n    // create new stream -- NEEDED???? experimenting\n    /*navigator.mediaDevices\n      .getUserMedia({ audio: true, video: false })\n      .then((stream) => {\n        this.setState({ gumStream: stream });\n      })\n      .catch(function (err) {\n        //enable the record button if getUSerMedia() fails\n        console.log(\"oops, can't get stream\", err);\n      });\n      */\n  }\n\n  componentDidMount() {\n    console.log(\"record CDM\", this.props.userMedia);\n    if ( this.props.immediateRecord )\n    {\n      console.log(\"start immediately\");\n      this.startRecord();\n      setImmediateOff();\n      window.addEventListener('keyup', (e) => { if (e.key == 'r') this.endRecord(); });\n    }\n  }\n\n\n  startRecord = () => {\n    if (this.props.recorder == null) return; // do nothing if recording isn't yet allowed\n\n    this.setState({ recordingState: true });\n    this.startTime = Date.now();\n    //this.state.mediaRecorder.start();\n    this.props.recorder.onComplete = (recorder, blob) => {\n      //createDownloadLink(blob, recorder.encoding);\n      this.props.saveTempAudio(blob, this.duration);\n    };\n    this.props.recorder.setOptions({\n      timeLimit: 120,\n      encodeAfterRecord: true,\n      mp3: {\n        bitRate: 160,\n      },\n    });\n\n    //start the recording process\n    setTimeout( () => this.props.recorder.startRecording(), 200 ); // delay start to avoid clicks and taps\n  }\n\n  render() {\n    var ret; // var for the value to be returned\n\n    if (navigator.mediaDevices) {\n      if (!this.state.recordingState) {\n        ret = (\n          <button\n            id=\"recordBtn\"\n            onClick={this.startRecord}\n          >\n            Record\n          </button>\n        );\n      } else {\n        ret = (\n          <button\n            id=\"stopBtn\"\n            onClick={this.endRecord}\n          >\n            stop\n          </button>\n        );\n      }\n    } else\n      ret = (\n        <span>\n          Your device is not supported by navigator.mediaDevices. Sorry.\n        </span>\n      );\n\n    return <React.Fragment>{ret}</React.Fragment>;\n  }\n}\n\n\n\nconst mapStateToProps = (state) => ({\n  immediateRecord: state.immediateRecord,\n  recorder: state.recorder,\n});\n\nconst mapDispatchToProps = {\n  setImmediateOff,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Record);\n"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SACEC,eADF,QAEO,wBAFP;;AAIA,MAAMC,MAAN,SAAqBH,KAAK,CAACI,SAA3B,CAAqC;EACnCC,WAAW,CAACC,KAAD,EAAQ;IACjB,MAAMA,KAAN;;IADiB,KAUnBC,SAVmB,GAUP,MAAM;MAChB,IAAI,KAAKD,KAAL,CAAWE,QAAX,IAAuB,IAA3B,EAAiC,OADjB,CACyB;;MAEzC,KAAKC,QAAL,CAAc;QAAEC,cAAc,EAAE;MAAlB,CAAd;MACA,KAAKC,QAAL,GAAgB,CAACC,IAAI,CAACC,GAAL,KAAa,KAAKC,SAAnB,IAAgC,IAAhD,CAJgB,CAMhB;;MACA,KAAKR,KAAL,CAAWE,QAAX,CAAoBO,eAApB,GAPgB,CAShB;;MACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACG,CA9BkB;;IAAA,KA4CnBC,WA5CmB,GA4CL,MAAM;MAClB,IAAI,KAAKV,KAAL,CAAWE,QAAX,IAAuB,IAA3B,EAAiC,OADf,CACuB;;MAEzC,KAAKC,QAAL,CAAc;QAAEC,cAAc,EAAE;MAAlB,CAAd;MACA,KAAKI,SAAL,GAAiBF,IAAI,CAACC,GAAL,EAAjB,CAJkB,CAKlB;;MACA,KAAKP,KAAL,CAAWE,QAAX,CAAoBS,UAApB,GAAiC,CAACT,QAAD,EAAWU,IAAX,KAAoB;QACnD;QACA,KAAKZ,KAAL,CAAWa,aAAX,CAAyBD,IAAzB,EAA+B,KAAKP,QAApC;MACD,CAHD;;MAIA,KAAKL,KAAL,CAAWE,QAAX,CAAoBY,UAApB,CAA+B;QAC7BC,SAAS,EAAE,GADkB;QAE7BC,iBAAiB,EAAE,IAFU;QAG7BC,GAAG,EAAE;UACHC,OAAO,EAAE;QADN;MAHwB,CAA/B,EAVkB,CAkBlB;;MACAC,UAAU,CAAE,MAAM,KAAKnB,KAAL,CAAWE,QAAX,CAAoBkB,cAApB,EAAR,EAA8C,GAA9C,CAAV,CAnBkB,CAmB6C;IAChE,CAhEkB;;IAGjB,KAAKC,KAAL,GAAa;MACXjB,cAAc,EAAE;IADL,CAAb;EAGD,CAPkC,CASnC;;;EAwBAkB,iBAAiB,GAAG;IAClBC,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0B,KAAKxB,KAAL,CAAWyB,SAArC;;IACA,IAAK,KAAKzB,KAAL,CAAW0B,eAAhB,EACA;MACEH,OAAO,CAACC,GAAR,CAAY,mBAAZ;MACA,KAAKd,WAAL;MACAd,eAAe;MACf+B,MAAM,CAACC,gBAAP,CAAwB,OAAxB,EAAkCC,CAAD,IAAO;QAAE,IAAIA,CAAC,CAACC,GAAF,IAAS,GAAb,EAAkB,KAAK7B,SAAL;MAAmB,CAA/E;IACD;EACF;;EAyBD8B,MAAM,GAAG;IACP,IAAIC,GAAJ,CADO,CACE;;IAET,IAAIC,SAAS,CAACC,YAAd,EAA4B;MAC1B,IAAI,CAAC,KAAKb,KAAL,CAAWjB,cAAhB,EAAgC;QAC9B4B,GAAG,gBACD;UACE,EAAE,EAAC,WADL;UAEE,OAAO,EAAE,KAAKtB,WAFhB;UAAA;UAAA;YAAA;YAAA;YAAA;UAAA;QAAA,YADF;MAQD,CATD,MASO;QACLsB,GAAG,gBACD;UACE,EAAE,EAAC,SADL;UAEE,OAAO,EAAE,KAAK/B,SAFhB;UAAA;UAAA;YAAA;YAAA;YAAA;UAAA;QAAA,UADF;MAQD;IACF,CApBD,MAqBE+B,GAAG,gBACD;MAAA;MAAA;QAAA;QAAA;QAAA;MAAA;IAAA,oEADF;;IAMF,oBAAO,oBAAC,KAAD,CAAO,QAAP;MAAA;MAAA;QAAA;QAAA;QAAA;MAAA;IAAA,GAAiBA,GAAjB,CAAP;EACD;;AAlGkC;;AAuGrC,MAAMG,eAAe,GAAId,KAAD,KAAY;EAClCK,eAAe,EAAEL,KAAK,CAACK,eADW;EAElCxB,QAAQ,EAAEmB,KAAK,CAACnB;AAFkB,CAAZ,CAAxB;;AAKA,MAAMkC,kBAAkB,GAAG;EACzBxC;AADyB,CAA3B;AAIA,eAAeD,OAAO,CAACwC,eAAD,EAAkBC,kBAAlB,CAAP,CAA6CvC,MAA7C,CAAf"},"metadata":{},"sourceType":"module"}