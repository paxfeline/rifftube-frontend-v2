{"ast":null,"code":"var _jsxFileName = \"/Users/davidnewberry/Documents/rifftube-git/RiffTube/front-end/src/components/YouTubeVideo/YouTubeVideo.js\";\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { setPlayerMode, setRiffPlaying, loadRiff, togglePlayerMode, setVideoDuration, EDIT_MODE, EDIT_NEW_MODE, PLAY_MODE, PAUSE_MODE } from '../../actions/index.js';\nimport AllowPlayback from './AllowPlayback.js'; // based on https://stackoverflow.com/questions/54017100/how-to-integrate-youtube-iframe-api-in-reactjs-solution\n\nclass YouTubeVideo extends React.Component {\n  constructor() {\n    super(...arguments);\n\n    this.componentDidMount = () => {\n      // On mount, check to see if the API script is already loaded\n      if (!window.YT || !window.YT.Player) {\n        // If not, load the script asynchronously\n        const tag = document.createElement('script');\n        tag.src = 'https://www.youtube.com/iframe_api'; // onYouTubeIframeAPIReady will load the video after the script is loaded\n\n        window.onYouTubeIframeAPIReady = this.loadVideo;\n        const firstScriptTag = document.getElementsByTagName('script')[0];\n        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n      } // If script is already there, load the video directly\n      else {\n        this.loadVideo();\n        this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n      }\n    };\n\n    this.loadVideo = () => {\n      if (!window.YT) return; // can be called by componentDidUpdate before window.YT has loaded\n\n      const {\n        id\n      } = this.props;\n      if (window.rifftubePlayer) window.rifftubePlayer.destroy();\n      this.player = new window.YT.Player('rifftube-player', {\n        videoId: id,\n        height: 390,\n        width: 640,\n        playerVars: {\n          playsinline: 1 // allows it to play inline on iOS\n\n        },\n        events: {\n          onReady: this.onPlayerReady,\n          onStateChange: this.onPlayerStateChange\n        }\n      });\n      window.rifftubePlayer = this.player; // store global reference (used to get current playback time when needed)\n    };\n\n    this.onPlayerReady = event => {\n      //event.target.playVideo();\n      this.props.setVideoDuration(event.target.getDuration());\n    };\n\n    this.checkForRiffsToLoad = t => {\n      this.props.riffs.forEach(riff => {\n        if ( // if no id, it's being saved\n        riff.id && //if it's an audio riff\n        riff.type === 'audio' && //if it's not loaded already\n        !this.props.riffsAudio.all[riff.id] && //!riff.payload &&\n        //if it's not loading\n        !this.props.riffsAudio.loading[riff.id] && //!riff.loading &&\n        // if the riff is in the future\n        riff.time >= t && // but is less than 10 seconds in the future\n        riff.time < t + 10) // load the riff to be played at the right time\n          this.props.loadRiff(riff.id);\n      });\n    };\n\n    this.onPlayerStateChange = _ref => {\n      let {\n        data\n      } = _ref;\n\n      /*\n          -1 (unstarted)\n          0 (ended)\n          1 (playing)\n          2 (paused)\n          3 (buffering)\n          5 (video cued).\n          */\n      // the following conditional leaves out some 'else's that should never occur\n      if (data === 1) {\n        // playing\n        // the following code is\n        // needed I think... for pausing during a riff.\n        // so that (subsiquent) 'zombie' riffs can be killed,\n        // I think.\n        this.curRiff = this.props.riffsPlaying;\n        /*******************************************************/\n        // this timer is responsible for showing and hiding riffs\n\n        this.riffInterval = setInterval(() => {\n          if (!(window.rifftubePlayer && typeof window.rifftubePlayer.getCurrentTime == 'function')) return;\n          let t = window.rifftubePlayer.getCurrentTime(); // if the MetaBar component exists, update its playhead\n\n          if (window.metaPlayHead && window.metaPlayHead.current) {\n            window.metaPlayHead.current.style.left = `${t / this.props.duration * 100}%`;\n            if (window.metaUpdate) window.metaUpdate(window.metaPlayHead.current);\n          } //\n\n\n          this.checkForRiffsToLoad(t); // first stop any zombie riffs\n\n          this.props.riffs.forEach((riff, index) => {\n            if (this.curRiff[index] && (t < riff.time || t > riff.time + riff.duration)) {\n              if (this.curRiff[index].inUse) this.curRiff[index].inUse = false; // by setting this to false, text riffs will be hidden\n\n              this.props.setRiffPlaying(index, false);\n              this.curRiff[index] = null;\n              if (riff.type === 'audio') // make sure all audio clips have stopped\n                this.audLock--;\n\n              if (!this.audLock) {\n                window.rifftubePlayer.setVolume(this.vol ? this.vol : 100); // hopefully unnecessary volume failsafe\n\n                delete this.vol;\n              }\n            }\n          }); // next start any that should be playing\n\n          this.props.riffs.forEach((riff, index) => {\n            // the riff will start playing within half a second, or will be skipped\n            if (!this.curRiff[index] && t > riff.time && t < riff.time + 0.5) {\n              this.props.setRiffPlaying(index, true);\n              this.curRiff[index] = true; // used for text only; overwritten for audio\n\n              if (riff.type === 'audio') {\n                if (!this.vol) {\n                  this.vol = window.rifftubePlayer.getVolume();\n                  window.rifftubePlayer.setVolume(this.vol * 0.25);\n                } // keeps track of how many audio tracks need to end before volume should be restored\n\n\n                if (!this.audLock) this.audLock = 1;else this.audLock++;\n\n                if (!this.props.riffsAudio.all[riff.id]) {\n                  //(!riff.payload) {\n                  return;\n                } // DEBUG - SHOULD BE REMOVED\n\n\n                var audioURL = URL.createObjectURL(this.props.riffsAudio.all[riff.id]); //(riff.payload);\n                //debugger;\n\n                window.lastRiff = this.props.riffsAudio.all[riff.id]; // riff.payload;\n                // FIX THIS:\n\n                for (let i = 0; i < window.audioPlayersCount; i++) {\n                  /*\n                  if ( window.audioContexts[i].inUse ) continue;\n                  let audioContext = window.audioContexts[i];\n                  window.audioContexts[i].inUse = true;\n                  var blob = riff.payload;\n                  new Response(blob).arrayBuffer().then(function(arrayBuffer) {\n                    window.audioContexts[0].decodeAudioData(arrayBuffer, audioData => {\n                      debugger;\n                      var source = window.audioContexts[i].createBufferSource();\n                      source.buffer = audioData;\n                      source.connect(window.audioContexts[i].destination);\n                      source.start()\n                    })\n                  });\n                  */\n                  let audio = window.audioPlayers[i];\n                  if (audio.inUse) continue;\n                  audio.inUse = true; // TEST:\n\n                  audio.srcEl.src = audioURL;\n                  audio.load();\n                  audio.play();\n                  /*\n                  var se = document.createElement('source');\n                  audio.appendChild(se);\n                  se.src = audioURL;\n                  //se.type = 'audio/webm';\n                  audio.load();\n                  audio.play();\n                  */\n                  // ORIG:\n\n                  /*\n                  audio.src = audioURL;\n                  audio.play();\n                  */\n\n                  this.curRiff[index] = audio; // audioContext;\n\n                  break;\n                }\n              }\n            }\n          });\n        }, 100); // 100/1000 = 1/10 s\n\n        if (this.props.mode !== PLAY_MODE) {\n          // change mode state\n          this.props.setPlayerMode(PLAY_MODE);\n        }\n      } // not playing\n      else {\n        // stop riff-check interval when not playing\n        clearInterval(this.riffInterval);\n\n        if (this.props.mode === PLAY_MODE) {\n          // change mode state\n          this.props.setPlayerMode(PAUSE_MODE);\n        }\n      }\n    };\n\n    this.componentDidUpdate = prevProps => {\n      // seems needed on more than just mounting\n      // (makes sense; the riff meta takes some time to load)\n      this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n\n      if (this.props.id !== prevProps.id) this.loadVideo();\n      if (!(this.player && this.player.getPlayerState)) return;\n\n      if (this.props.mode !== prevProps.mode) {\n        if ((this.props.mode === EDIT_MODE || this.props.mode === EDIT_NEW_MODE || this.props.mode === PAUSE_MODE) && this.player.getPlayerState() === 1) {\n          this.player.pauseVideo();\n        } else if (this.props.mode === PLAY_MODE && this.player.getPlayerState() !== 1) {\n          this.player.playVideo();\n        }\n      }\n    };\n\n    this.render = () => {\n      return /*#__PURE__*/React.createElement(React.Fragment, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 280,\n          columnNumber: 7\n        }\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        className: \"rifftube-container\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 281,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(AllowPlayback, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 282,\n          columnNumber: 11\n        }\n      }), /*#__PURE__*/React.createElement(\"div\", {\n        className: \"rifftube-overlay\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 283,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        className: \"rifftube-riffs-container\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 284,\n          columnNumber: 13\n        }\n      }, Object.keys(this.props.riffsPlaying).filter(i => this.props.riffsPlaying[i] && this.props.riffs[i] && this.props.riffs[i].type === 'text').map(key => /*#__PURE__*/React.createElement(\"div\", {\n        key: this.props.riffs[key].id,\n        className: \"rifftube-textriff\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 293,\n          columnNumber: 19\n        }\n      }, this.props.riffs[key].payload)))), /*#__PURE__*/React.createElement(\"div\", {\n        id: \"rifftube-player\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 302,\n          columnNumber: 11\n        }\n      })));\n    };\n  }\n\n}\n\nconst mapStateToProps = state => ({\n  mode: state.mode,\n  //riffs: state.riffs.all,\n  riffsPlaying: state.riffsPlaying,\n  googleUser: state.googleUser,\n  duration: state.duration,\n  riffsAudio: state.riffsAudio\n});\n\nconst mapDispatchToProps = {\n  setPlayerMode,\n  setRiffPlaying,\n  togglePlayerMode,\n  loadRiff,\n  setVideoDuration\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(YouTubeVideo);","map":{"version":3,"names":["React","connect","setPlayerMode","setRiffPlaying","loadRiff","togglePlayerMode","setVideoDuration","EDIT_MODE","EDIT_NEW_MODE","PLAY_MODE","PAUSE_MODE","AllowPlayback","YouTubeVideo","Component","componentDidMount","window","YT","Player","tag","document","createElement","src","onYouTubeIframeAPIReady","loadVideo","firstScriptTag","getElementsByTagName","parentNode","insertBefore","checkForRiffsToLoad","id","props","rifftubePlayer","destroy","player","videoId","height","width","playerVars","playsinline","events","onReady","onPlayerReady","onStateChange","onPlayerStateChange","event","target","getDuration","t","riffs","forEach","riff","type","riffsAudio","all","loading","time","data","curRiff","riffsPlaying","riffInterval","setInterval","getCurrentTime","metaPlayHead","current","style","left","duration","metaUpdate","index","inUse","audLock","setVolume","vol","getVolume","audioURL","URL","createObjectURL","lastRiff","i","audioPlayersCount","audio","audioPlayers","srcEl","load","play","mode","clearInterval","componentDidUpdate","prevProps","getPlayerState","pauseVideo","playVideo","render","Object","keys","filter","map","key","payload","mapStateToProps","state","googleUser","mapDispatchToProps"],"sources":["/Users/davidnewberry/Documents/rifftube-git/RiffTube/front-end/src/components/YouTubeVideo/YouTubeVideo.js"],"sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport {\n  setPlayerMode,\n  setRiffPlaying,\n  loadRiff,\n  togglePlayerMode,\n  setVideoDuration,\n  EDIT_MODE,\n  EDIT_NEW_MODE,\n  PLAY_MODE,\n  PAUSE_MODE,\n} from '../../actions/index.js';\nimport AllowPlayback from './AllowPlayback.js';\n\n// based on https://stackoverflow.com/questions/54017100/how-to-integrate-youtube-iframe-api-in-reactjs-solution\n\nclass YouTubeVideo extends React.Component {\n  componentDidMount = () => {\n    // On mount, check to see if the API script is already loaded\n\n    if (!window.YT || !window.YT.Player) {\n      // If not, load the script asynchronously\n      const tag = document.createElement('script');\n      tag.src = 'https://www.youtube.com/iframe_api';\n\n      // onYouTubeIframeAPIReady will load the video after the script is loaded\n      window.onYouTubeIframeAPIReady = this.loadVideo;\n\n      const firstScriptTag = document.getElementsByTagName('script')[0];\n      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n    } // If script is already there, load the video directly\n    else {\n      this.loadVideo();\n      this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n    }\n  };\n\n  loadVideo = () => {\n    if (!window.YT) return; // can be called by componentDidUpdate before window.YT has loaded\n\n    const { id } = this.props;\n\n    if (window.rifftubePlayer) window.rifftubePlayer.destroy();\n\n    this.player = new window.YT.Player('rifftube-player', {\n      videoId: id,\n      height: 390,\n      width: 640,\n      playerVars: {\n        playsinline: 1, // allows it to play inline on iOS\n      },\n      events: {\n        onReady: this.onPlayerReady,\n        onStateChange: this.onPlayerStateChange,\n      },\n    });\n\n    window.rifftubePlayer = this.player; // store global reference (used to get current playback time when needed)\n  };\n\n  onPlayerReady = (event) => {\n    //event.target.playVideo();\n\n    this.props.setVideoDuration(event.target.getDuration());\n  };\n\n  // TODO: account for muted riffs!!!!\n  checkForRiffsToLoad = (t) => {\n    this.props.riffs.forEach((riff) => {\n      if (\n        // if no id, it's being saved\n        riff.id &&\n        //if it's an audio riff\n        riff.type === 'audio' &&\n        //if it's not loaded already\n        !this.props.riffsAudio.all[riff.id] && //!riff.payload &&\n        //if it's not loading\n        !this.props.riffsAudio.loading[riff.id] && //!riff.loading &&\n        // if the riff is in the future\n        riff.time >= t &&\n        // but is less than 10 seconds in the future\n        riff.time < t + 10\n      )\n        // load the riff to be played at the right time\n        this.props.loadRiff(riff.id);\n    });\n  };\n\n  onPlayerStateChange = ({ data }) => {\n    /*\n        -1 (unstarted)\n        0 (ended)\n        1 (playing)\n        2 (paused)\n        3 (buffering)\n        5 (video cued).\n        */\n\n    // the following conditional leaves out some 'else's that should never occur\n\n    if (data === 1) {\n      // playing\n\n      // the following code is\n      // needed I think... for pausing during a riff.\n      // so that (subsiquent) 'zombie' riffs can be killed,\n      // I think.\n      this.curRiff = this.props.riffsPlaying;\n\n      /*******************************************************/\n      // this timer is responsible for showing and hiding riffs\n      this.riffInterval = setInterval(() => {\n        if (\n          !(\n            window.rifftubePlayer &&\n            typeof window.rifftubePlayer.getCurrentTime == 'function'\n          )\n        )\n          return;\n\n        let t = window.rifftubePlayer.getCurrentTime();\n\n        // if the MetaBar component exists, update its playhead\n        if (window.metaPlayHead && window.metaPlayHead.current) {\n          window.metaPlayHead.current.style.left = `${\n            (t / this.props.duration) * 100\n          }%`;\n          if (window.metaUpdate) window.metaUpdate(window.metaPlayHead.current);\n        }\n\n        //\n        this.checkForRiffsToLoad(t);\n\n        // first stop any zombie riffs\n        this.props.riffs.forEach((riff, index) => {\n          if (\n            this.curRiff[index] &&\n            (t < riff.time || t > riff.time + riff.duration)\n          ) {\n            if (this.curRiff[index].inUse) this.curRiff[index].inUse = false;\n\n            // by setting this to false, text riffs will be hidden\n            this.props.setRiffPlaying(index, false);\n            this.curRiff[index] = null;\n\n            if (riff.type === 'audio')\n              // make sure all audio clips have stopped\n              this.audLock--;\n            if (!this.audLock) {\n              window.rifftubePlayer.setVolume(this.vol ? this.vol : 100); // hopefully unnecessary volume failsafe\n              delete this.vol;\n            }\n          }\n        });\n\n        // next start any that should be playing\n        this.props.riffs.forEach((riff, index) => {\n          // the riff will start playing within half a second, or will be skipped\n          if (!this.curRiff[index] && t > riff.time && t < riff.time + 0.5) {\n            this.props.setRiffPlaying(index, true);\n            this.curRiff[index] = true; // used for text only; overwritten for audio\n\n            if (riff.type === 'audio') {\n              if (!this.vol) {\n                this.vol = window.rifftubePlayer.getVolume();\n                window.rifftubePlayer.setVolume(this.vol * 0.25);\n              }\n\n              // keeps track of how many audio tracks need to end before volume should be restored\n              if (!this.audLock) this.audLock = 1;\n              else this.audLock++;\n\n              if (!this.props.riffsAudio.all[riff.id]) {\n                //(!riff.payload) {\n                return;\n              } // DEBUG - SHOULD BE REMOVED\n              var audioURL = URL.createObjectURL(\n                this.props.riffsAudio.all[riff.id]\n              ); //(riff.payload);\n              //debugger;\n\n              window.lastRiff = this.props.riffsAudio.all[riff.id]; // riff.payload;\n\n              // FIX THIS:\n\n              for (let i = 0; i < window.audioPlayersCount; i++) {\n                /*\n                if ( window.audioContexts[i].inUse ) continue;\n                let audioContext = window.audioContexts[i];\n                window.audioContexts[i].inUse = true;\n                var blob = riff.payload;\n                new Response(blob).arrayBuffer().then(function(arrayBuffer) {\n                  window.audioContexts[0].decodeAudioData(arrayBuffer, audioData => {\n                    debugger;\n                    var source = window.audioContexts[i].createBufferSource();\n                    source.buffer = audioData;\n                    source.connect(window.audioContexts[i].destination);\n                    source.start()\n                  })\n                });\n                */\n\n                let audio = window.audioPlayers[i];\n                if (audio.inUse) continue;\n                audio.inUse = true;\n\n                // TEST:\n                audio.srcEl.src = audioURL;\n                audio.load();\n                audio.play();\n\n                /*\n                var se = document.createElement('source');\n                audio.appendChild(se);\n                se.src = audioURL;\n                //se.type = 'audio/webm';\n                audio.load();\n                audio.play();\n                */\n\n                // ORIG:\n                /*\n                audio.src = audioURL;\n                audio.play();\n                */\n\n                this.curRiff[index] = audio; // audioContext;\n                break;\n              }\n            }\n          }\n        });\n      }, 100); // 100/1000 = 1/10 s\n\n      if (this.props.mode !== PLAY_MODE) {\n        // change mode state\n        this.props.setPlayerMode(PLAY_MODE);\n      }\n    } // not playing\n    else {\n      // stop riff-check interval when not playing\n      clearInterval(this.riffInterval);\n\n      if (this.props.mode === PLAY_MODE) {\n        // change mode state\n        this.props.setPlayerMode(PAUSE_MODE);\n      }\n    }\n  };\n\n  componentDidUpdate = (prevProps) => {\n    // seems needed on more than just mounting\n    // (makes sense; the riff meta takes some time to load)\n    this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n\n    if (this.props.id !== prevProps.id) this.loadVideo();\n\n    if (!(this.player && this.player.getPlayerState)) return;\n\n    if (this.props.mode !== prevProps.mode) {\n      if (\n        (this.props.mode === EDIT_MODE ||\n          this.props.mode === EDIT_NEW_MODE ||\n          this.props.mode === PAUSE_MODE) &&\n        this.player.getPlayerState() === 1\n      ) {\n        this.player.pauseVideo();\n      } else if (\n        this.props.mode === PLAY_MODE &&\n        this.player.getPlayerState() !== 1\n      ) {\n        this.player.playVideo();\n      }\n    }\n  };\n\n  render = () => {\n    return (\n      <React.Fragment>\n        <div className=\"rifftube-container\">\n          <AllowPlayback />\n          <div className=\"rifftube-overlay\">\n            <div className=\"rifftube-riffs-container\">\n              {Object.keys(this.props.riffsPlaying)\n                .filter(\n                  (i) =>\n                    this.props.riffsPlaying[i] &&\n                    this.props.riffs[i] &&\n                    this.props.riffs[i].type === 'text'\n                )\n                .map((key) => (\n                  <div\n                    key={this.props.riffs[key].id}\n                    className=\"rifftube-textriff\"\n                  >\n                    {this.props.riffs[key].payload}\n                  </div>\n                ))}\n            </div>\n          </div>\n          <div id=\"rifftube-player\" />\n        </div>\n      </React.Fragment>\n    );\n  };\n}\n\nconst mapStateToProps = (state) => ({\n  mode: state.mode,\n  //riffs: state.riffs.all,\n  riffsPlaying: state.riffsPlaying,\n  googleUser: state.googleUser,\n  duration: state.duration,\n  riffsAudio: state.riffsAudio,\n});\n\nconst mapDispatchToProps = {\n  setPlayerMode,\n  setRiffPlaying,\n  togglePlayerMode,\n  loadRiff,\n  setVideoDuration,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(YouTubeVideo);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}